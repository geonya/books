컴퓨터 아키텍처라는 말은 컴퓨터의 여러 구성 요소를 배치하는 방법을 뜻함

최신 마이크로프로세서의 회로 확대 사진을 보면 칩에서 가장 큰 영역이 메모리 처리에 할당됐다는 점을 알 수 있다.

멀티태스킹은 여러 프로그램을 동시에 실행하는 기능이거나 최소한 겉으로 보기에는 여러 프로그램이 동시에 실행되는 것처럼 보이게 하는 기능을 뜻한다.
여러 프로그램을 실행하다는 말은 프로그램들의 실행을 제어하기 위한 감독 프로그램인 운영체제 OS : operation system 가 있어야 한다는 사실을 암시한다.

CPU는 4장에서 본 것처럼 ALU, 레지스터, 실행 장치의 조합이다.

멀니프로세서 시스템은 단일 CPU보다 훨씬 더 좋은 성능을 얻어내기 위한 방법이다.
여러 CPU를 활용할 수 있도록 프로그램을 병렬화하는 문제는 아주 많은 수학 계산이 필요한 몇몇 경ㅇ에는 잘 작동하지만 일반저깅ㄴ 경우에는 풀 수 없는 문제다.
하지만 그래팍 사용자 인터페이스를 제공하는 초기 워크스테이션에서는 여러 프로그램을 동시에 실행할 수 있다는 점이 큰 이점이었다.

회로 크기가 계속 작아지는데 속도를 빠르게 하기 위해 전력을 더 소모하면서 단위 면적당 열 발생량이 많아져 2000년 경 프로세서는 전력 장벽에 부딪힌다.
전력 장벽은 열로 인해 회로를 이루는 물지의 녹는점 이상으로 온도가 올라가는 거을 방지하면서 회로를 소형화 고성능화하기가 어려워졌다는 뜻이다.
사람들은 작아진 회로 크기를 활용한 새로운 해결책을 찾아내다. CPU의 정의가 바뀌었다. 예전에 CPU라고 부르던 것을 요즘은 프로세서 코어라고 부른다. 이런 코어가 여럿 들어가는 멀티코어 프로세서가 이제는 일반적으로 쓰인다.

마이크로프로세서는 보통 큰 시스템에 들어가는 부품으로 쓰이고, 마이크로컴퓨터는 식기세척기 등에서 찾을 수 있는 (단일 칩으로 된) 작은 컴퓨터다.

프로그래머들이 피하고 싶어 하는 일 중 하나는 똑같은 코드를 두 번 이상 작성하는 것이다. 이렇게 코드 반복을 피하는 데는 게으름 외에도 여러 가지 충분한 이유가 있다. 예를 들어 중복된 코드를 줄이면 코드가 메로리를 덜 차지하고 코드에 버그가 있는 경우 여러 군데를 반복해 고치지 않고 한 군데만 고치면 된다는 장점이 있다.

함수는 코드를 재사용하는 주요 수단이다.

함수를 호출하는 부분에서 함수를 실행하고 다시 원래 자리로 돌아올 방법이 필요하다. 원래 자리로 돌아오기 위해서는 어디서 함수로 들어갔는지를 기억해야 한다.
이 위치는 바로 프로그램 카운터의 값이다.

197p

스택

함수가 다른 함수를 호출하거나 함수가 자기 자신을 호출하는 경우도 자주 있다. (재귀)

함수 호출에서 돌아올 대는 접시 더미 맨 위의 접시를 보고 반환 주소를 결정한 다음, 접시를 제거한다. 다른 말로 이런 구조를 물건을 샇아올린다는 뜻의 스택이라고 부른다.
LIFO (Last In, First Out)이라고 브리ㄱ도 한다.
스택에 물건을 push 해 넣고, 스택에서 물건을 pop해서 제거한다.

스택에 물건을 푸시하는데 더 이상 들어갈 공간이 없으면 이를 stack overflow 라고 말한다.
빈 스택에서 물건을 가져오려고 하는 경우를 stack underflow라고 부른다.
스택은 단지 반환 주소만 저장하기 위한 장소는 아니다.
함수를 호출할 때 이 지역 변숫값을 그냥 덮어쓰면 안 된다. 대신, 지역 변수도 스택에 저장해야 한다. 이렇게 하면 각각의 함수 호출이 서로 독립적이게 된다. 이렇게 함수가 호출될 대마다 스택에 저장되는 데이터의 모음을 스택 프레임 stack frame 이라고 부른다.

폴링 : 계속 다른 작업이 있는지 체크하는 방법
폴링은 어느 정도 유용하지만 다른 작업을 검사하는데 너무 많은 시간을 소모한다.

프로그램을 잠깐 중단 interrupt 시켜서 주의를 기울여야 하는 외부의 요소에 대응할 수 있게 만들 방법이 필요하다.
실행 장치에 새로운 하드웨어 기능을 추가할 때다.

인터럽트 시스템은 적절한 신호가 들어오면 CPU 실행을 잠깐 중단시킬 수 있는 핀이나 전기 연결을 포함한다. 핀은 칩에 연결된 전기적 접점을 뜻하는 말이다. 칩에는 핀처럼 보이는 부품이 잇는 경우가 많았지만 장치 크기가 줄어듦에 따라 다른 방식도 쓰이기 시작했다.
많은 프로세서 칩에는 통합 주변장치가 들어 있고 이런 장치들은 내부적으로 인터럽트 시스템에 연결되어 있다.

인터럽트 시스템이 작동되는 방식
CPU가 주의를 기울여야 하는 주변 장치는 인터럽트 요청을 생성한다.
프로세서는 현재 실행 중인 명령어를 끝까지 실행한다. 그 후 프로세서는 현재 실행 중인 프로그램을 잠시 중단시키고 인터럽트 핸들러라는 전혀 다른 프로그램을 실행하기 시작한다.
인터럽트 핸드러가 필요한 작업을 다 마치고 나면 원래 실행 중이던 프로그램이 중단된 위치부터 다시 실행을 계속한다. 인터럽트 핸들러는 함수다.

1. 인터럽트에 대한 응답시간
2. 인터럽트 서비스 하고 나중에 다시 원래대로 돌아오기 위해서는 현재 상태를 저장할 방법이 필요하다. 예를 들어
   인터럽트가 걸린 시점에 실행 중이던 프로그램이 어떤 값을 저장하고 있었다면, 인터럽트 핸들러는 그 레지스터를 저장했다가 나중에 원래 프로그램으로 돌아오기 전에 레지스터값을 복구해줘야 한다.

인터럽트 시스템은 서비스 후 돌아올 프로그램 위치를 스택에 저장한다. 인터럽트 핸들러는 자신이 덮어쓸 레지스터를 모두 저장해야 할 책임이 있다.
이렇게 약속하면 인터럽트 핸들어가 저장해야 하는 요소를 최소화해서 가장 빨리 인터럽트 서비스를 할 수 있다.

운영체제는 일종의 가상 인터럽트나 소프트웨어 인터럽트 시스템을 제공하기도 한다. 예를 들어, 유닉스 운영체제는 시그널 메커니즘, 최근 개발된 시스템들은 보통 이를 이벤트라고 부른다.

어떤 프로그램을 운영체제 또는 운영체제 커널이라고 부른다.
OS와 OS가 관리하는 프로그램을 구분하기 위해 OS를 시스템 프로그램이라고 부르고 다른 모든 프로그램을 사용자 프록램이나 프로세스라고 부른다.

사용자 프로그램의 실행 시간을 조절하는 스케쥴링 기법을 시분할이라고부른다.
시분할 방식에서는 시간을 정해진 간격으로 나누고, 정해진 시간 간격 동안 사용자 프로그램을 실행한다.
사용자 프로그램 상태 또는 문맥(context) 레지스터의 상태와 프로그램이 사용 중인 메모리의 상태를 뜻한다.
이때 메모리에는 스택도 포함된다.

상대 주소 지정을 사용하면 프로그램을 메모리의 원하는 위치로 자유롭게 재배치할 수 있다.

메모리 관리 장치
모든 것이 인터넷에 연결되어 있고, 통신 작업은 계속해서 백그라운드에서 실행돼야 하기 때문에 멀티태스킹이 필수가 인덱스 레지스터와 상대 주소 지정이 멀티태스킹에 도움이될 수 있지만, 이들만으로 충분하지는 않다.

메모리 관리 장치 : MMU : memory management unit
OS는 MMU를 사용해 사용자 프로그램에서 가장 메머리를 제공한다.

CPU에는 컴퓨터가 시스템 모드에 있는지 사용자 모드에 있는지 결정하는 비트가 어떤 레지스터 안에 들어 있다.
I/O를 처리하는 명렁어 등 일부 명령어는 특권 명령어라서 오직 시스템 모드에서만 실행할 수 있다.
트랩이나 시스템 콜이라고 부르는 특별한 명렁어를 통해 사용자 모드에서 실행 중인 프로그램이 시스템 모드 프로그램에게 요청을 보낼 수 있다.
이 방식의 장점

1. 이 방식은 사용자 프로그램으로부터 운영체제를 보호하고, 사용자 프고르매을 다른 사용자 프로그램으로부터 보호한다.
2. 사용자 프로그램이 MMU 등의 몇몇 요소에 손을 댈 수 없기 때문에 운영체제가 프로그램에 대한 자원 할당을 전적으로 제어할 수 있다. 하드웨어 예외는 오직 시스템 공간에서만 처리된다.

메모리 계층과 성능

가상 메모리와 스와핑은 메모리 계층이라는 개념을 소개했다. 사용자 프로그램에게는 모든 메모리가 같아 보이지만 메모리 시스템 내부에서 일어나는 일은 시스템 성능에 큰 영향을 끼친다.

전반적으로 레지스터가 전체 메모리에서 차지하는 비율은 점점 작아져 왔다. 프로세서는 보통 RAM으로 이뤄진 주 메모리와 통시하는데, 주 메모리는 프로세서에 1/10 정도밖에 속도가 나지 않는다.
디스크 드라이브 등의 대량 저장장치는 프로세서보다 백만배 느릴 수도 있다.
레지스터 : 냉장고
주 메모리 : 가게
대용량 저장장치 : 창고

CPU 메모리 컨트롤러 하드웨어는 메모리에서 연속된 열에 있는 데이터를 한꺼번에 가져온다.

캐시 일관성을 유지하는 것은 아주 어려운 문제다.

코 프로세서

프로세서 코어는 아주 복잡한 회로로 이뤄졌다. 몇 가지 연산을 코프로세서라는 더 단순한 회로에 위임하면 프로세서 코어가 일반적인 연산에 활용할 수 있는 공간을 더 확보할 수 있다.

예를 들어 프로세서 자체에 부동소수점 수 연산을 처리할 회로를 만들 공간이 없어서 부동소수점 연산용 코프로세서를 사용하는 경우가 있었다 요즘은 그래픽 처리 등 여러가지 기능을 담당하는 코로세서가 한 칩에 같이 들어가 있는 경우가 많다.

프그램이 디스크 드라이브 등ㅢ 더 느리고 값ㅏㄴ 메모리에 들어 있고 이ㄹ 불러온다는 뜻이다. 그고 가상 메모리 시템이 스와핑 하ㄴ서 디스크에 메모리 내용을 저장하거나 디스크에서 메모리 데터나 프로그램을 읽어어온다는 사실도 살펴봤다.

대부분의 프로그램은 동적 데이터를 다뤄야 한다. 동적 데이터는 프그램을 실행하기 전에는 크기를 알 수 없는 데이터를 말한다.

동적 데이터는 주로 정적 데이터가 차지하는 영역의 바로 위 영역에 쌓이며 이를 힙이고 한다.
더 많은 데이터를 저장해야할 경우 스택은 아로 자라나는 반면, 힙은 위로 자라난다.
힙과 스택이 서로 충돌하지 않게 하는 것이 중요하다.

관련 함수를 한데 모아서 라이브러리로 만드는 것이다.

본격적인 프로그램은 라이브러리뿐 아니라, 여러 조각으로 이뤄진다. 프로그램 전부를 한 파일에 저장할 수도 있지만 이를 여러 파일로 나눠놓는 편이 더 좋은 이유가 있다. 가ㅇ 큰 장점은 여러 사람이 한 프로그램이 여러 부분을 동시에 개발할 수 있다는 점이다.

- 프로그램을 여러 조각으로 나누면 이 모든 조각을 하나로 엮거나 연결할 방법이 필요하다. 각 프로그램을 링크하기 편한 형식의 매개 파일로 나누고 링커라는 특별한 프로그램을 사용해 여러 조각을 하나로 연결해 실행한다.
  과거 다양한 매개 파일 형식이 생겨났다. 실행과 링크가 가능한 형식은 현재 가장 유명한 매개 파일 형식이다.

- 공유 라이브러리를 사용하는 동적 링크를 발명했다.
  공유 라이브러리에서 가져온 명령어는 이 라이브러리를 사용하는 모든 프로그램에서 공통적이라는 사실에 유의하라. 이로 인해 라이브러리 함수를 작성할 때 호출하는 프로그램의 스택과 힙을 사용하도록 함수를 설계해야만 한다.
- 프로그램에는 진입점이 있다. 진입점은 프로그램의 첫 번째 명령어가 위치한 주소를 뜻한다. 하지만 우리의 직과 달리 실제 프로그램이 실행될 때 사장 먼저 실행되는 명렁어는 진입점에 있는 명렁어가 아니다. 프로그램을 이루는 모든 부분이 하나로 합쳐져서 실행파일을 이룰 때 런타임 라이브러리가 추가된다.
  실제로 이 런타임 라이브러리에 있는 명령어가 먼저 살행되고 나중에 진입점의 명령어가 실행된다.
- 런타임 라이브러리는 메모리 설정을 책임진다. 이 말은 런타임 라이브러리가 스택과 힙 영역을 설정한다는 뜻이다. 런타임 라이브러리는 정적 데이터에 위치한 데이터의 초깃값도 설정한다. 이런 값들은 실행 파일에 들어 있고 시스템에서 메모리를 할당 받은 직후 실행 파일에서 메모리로 복사돼야 한다.
  런타임 라이브러리는 더 많은 기능을 수행한다. 특히 언어가 복잡해지면 런타임 라이브러리의 기능도 더 복잡해진다.

- 메모리 전력 소비
- 지금까지는 성능 측면에서 메모리에 접근했다. 데이터를 메모리에서 이리저리 옮기려면 전력이 소비된다. 데스크톱 컴퓨터에서는 이런 전력 소비가 아주 중요한 일은 아니지만 모바일 장치에서는 전력 소비가 중요하다.
