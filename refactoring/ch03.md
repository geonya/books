_220523_

# [Refactoring] Ch.03 코드에서 나는 악취

### 냄새 나면 당장 갈아라

- 리팩터링을 언제 시작하고 언제 그만할지를 판단하는 일은 리팩터링의 작동 원리를 아는 것 못지않게 중요하다.
- 코드의 냄새를 맡아라

## 3.1 기이한 이름 Mysterious Name

- 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 엄청나게 신경 써서 이름을 지어야 한다.
- 이름만 잘 지어도 나중에 문맥을 파악하느라 헤매는 시간을 크게 절약할 수 있다.
- 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다.

## 3.2 중복 코드 Duplicated Code

- 똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다.

## 3.3 긴 함수 Long Function

- 마치 연산하는 부분이 하나도 없어 보이며 코드가 끝없이 위임하는 방식으로 작성
- `간접 호출 효과` : 코드를 이해하고 공유하고 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것이다.
- 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다. (이름만 봐도 함수가 하는 일을 알 수 있도록)
- 함수를 최대한 잘게 쪼개고 주석을 달아야할 만한 부분은 무조건 함수로 만든다.
- 함수 본문에는 원래 주석으로 설명하려던 코드가 담기고, 함수 이름은 동작 방식이 아닌 의도가 드러나게 짓는다.
- `함수 추출하기` : 함수 본문에서 따로 묶어 빼내 좋은 코드 덩어리를 찾아 새로운 함수로 만들기
- _코드가 단 한 줄이어도 따로 설명할 필요가 있다면 함수로 추출하는 게 좋다._

## 3.4 긴 매개변수 목록 Logn Parameter List

- 매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많다.
- `매개변수를 질의 함수로 바꾸기`
- `객체 통째로 넘기기`
- `매개변수 객체 만들기`
- `플래그 인수 제거하기`
- `여러 함수를 클래스로 묶기` : 클래스는 매개변수 목록을 줄이는 데 효과적인 수단이기도 하다. 특히 여러 개의 함수가 특정 매개변수들의 값을 공통을 사용할 때 유용하다.

## 3.5 전역 데이터 Global Data

- 전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는 게 문제다.
- `변수 캡슐화하기` : 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 된다.
- 더 나아가 접근자 함수들을 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록 **접근 범위를 최소로 줄이는 것**도 좋다.

## 3.6 가변 데이터 Mutable Date

- 무분별한 데이터 수정은 버그의 원인이 된다.
- 함수형 프로그래밍에서는 데이터는 절대 변하지 않고, 데이터를 변경하려면 반드시 (원래 데이터는 그대로 둔 채) 변경하려는 값에 해당하는 `복사본`을 만들어서 반환한다는 개념을 기본으로 삼고 있다.
- `변수 캡슐화하기` : 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽다.
- `변수 쪼개기` : 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신할 때 용도별로 독립 변수에 저장하게 하여 값 갱신이 문제를 일으킬 여지를 없앤다.
- `문장 슬라이드하기`, `함수 추출하기` : 무언가를 갱신하는 코드로부터 부작용이 없는 코드를 분리한다.
- `질의 함수와 변경 함수 분리하기` API를 만들때 부작용이 있는 코드를 호출할 수 없게 함
- `세터 제거하기` : 세터를 호출하는 클라이언트를 찾는 것만으로도 변수의 유효범위를 줄이는 데 도움이 될 때가 있다.

- `파생 변수를 질의 함수로 바꾸기`
- `여러 함수를 클래스로 묶기` `여러 함수를 변환 함수로 묶기` : 변수를 갱신하는 코드들의 유효범위를 (클래스나 변환으로) 제한
- `참조를 값으로 바꾸기` : 구조체처럼 내부 필드에 데이터를 담고 있는 변수라면 내부 필드를 직접 수정하지 말고 구조체를 통째로 교체하는 편이 낫다.

## 3.7 뒤엉킨 변경 Divergent Change

- 뒤엉킨 변경은 단일 책임 원칙 Single Responsibility Principle (SRP) 이 제대로 지켜지지 않을 때 나타난다.
- `단계 쪼개기` : 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하게 하는 식으로 단계를 분리한다.
- `함수 옮기기` : 전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면, 각 맥락에 해당하는 적당한 모듈들을 만들어서 관련 함수를 모은다.
- `함수 추출하기` : 여러 맥락의 일에 관려하는 함수가 있다면 옮기기 전에 함수를 추출한다.
- `클래스 추출하기` : 모듈이 클래스일 때 이 방법으로 맥락별로 분리한다.

## 3.8 산탄총 수술 Shotgun Surgery

- 함께 변경되는 대상들을 `함수 옮기기` `필드 옮기기`로 모두 한 모듈에 묶어두면 좋다.
- 메서드나 클래스가 비대해지지만, 나중에 추출하기 리팩터링으로 더 좋은 형태로 분리할 수 있다.

## 3.9 기능 편애 Feature Envy

- 프로그램을 모듈화할 때는 코드를 여러 영역으로 나눈 뒤 영역 안에서 이뤄지는 상호작용은 최대한 늘리고 영역 사이에서 이뤄지는 상호작용은 최소로 줄이는 데 주력한다.
- 기능 편애는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 더 많을 때 풍기는 냄새다.
- 이 함수가 데이터와 가까이 있고 싶어 한다는 의중이 뚜렷이 드러날 때는 소원대로 데이터 근처로 옮겨주면 된다. `함수 옮기기`
- 함수의 일부에서만 기능을 편애할 때는 그 부분만 독립 함수로 빼낸 다음 `함수 추출하기` 원하는 모듈로 보내준다 `함수 옮기기`
- 함수가 사용하는 모듈이 다양하다면? `함수 추출하기`로 함수를 여러 조각으로 나눈 후 각각을 적합한 모듈로 옮겨라
- _"함께 변경할 대상을 한 데 모으는 것"_

## 3.10 데이터 뭉치 Data Clumps

- 필드 형태의 데이터 뭉치를 찾아서 `클래스 추출하기`로 하나의 객체로 묶는다.
- `매개 변수 객체 만들기` 나 `객체 통째로 넘기기`를 적용해서 매개변수 수를 줄여본다. -> 메서드 호출 코드가 간결해짐
- 기능 편애를 없애는 과정에서 새로운 클래스를 만들었다면 이어서 그 클래스로 옮기면 좋을 동작은 없는지 살펴보자.

## 3.11 기본형 집착 Primitive Obsession

- 주어진 문제에 딱 맞는 기초 타입(화폐, 좌표, 구간 등)을 직접 정의하기를 꺼리는 경우가 많은데
- `기본형 객체로 바꾸기`를 적용하면 기본형을 의미 있는 자료형들로 업그레이드 시켜줄 수 있다.
- 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드로 쓰였다면 `타입 코드를 서브클래스로 바꾸기` `조건부 로직을 다형성으로 바꾸기`를 적용해보자
- 기본형 그룹도 데이터 뭉치다. `클래스 추출하기` `매개변수 객체 만들기` 를 적용해보자.

## 3.12 반복되는 switch 문 Repeated Switches

- 중복된 switch 문이 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 switch 문들도 모두 찾아서 함께 수정해야 하기 때문이다.
- 똑같이 반복되는 switch 문이나 if/else 문을 집중해서 검토하고 개선해야 한다.

## 3.13 반복문 Loop

- `반복문을 파이프라인으로 바꾸기` 를 적용해서 반복문을 최대한 제거하자.

## 3.14 성의 없는 요소

- 빈껍데기 같은 클래스나 함수들과 같은 프로그램 요소를 `함수 인라인하기` `클래스 인라인하기` `계층 합치기` 로 처리하라.

_220523_
