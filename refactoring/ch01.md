# Ch.01 리팩터링 : 첫번째 예시

## 1.3 리팩터링의 첫 단계

-   리팩토링하기 전에 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가진단하도록 만든다.

## 1.4 statement() 함수 쪼개기

```javascript
const invoices = [
	{
		customer: "BigCo",
		performances: [
			{
				playID: "hamlet",
				audience: 55,
			},
			{
				playID: "as-like",
				audience: 35,
			},
			{
				playID: "othello",
				audience: 40,
			},
		],
	},
];

const plays = {
	hamlet: { name: "Hamlet", type: "tregedy" },
	"as-like": { name: "As You Like It", type: "comedy" },
	othello: { name: "Othello", type: "tregedy" },
};

function statement(invoice, plays) {
	let totalAmount = 0;
	let volumeCredits = 0;
	let result = `청구 내역 ( 고객명 : ${invoice.customer}\n`;
	const format = new Intl.NumberFormat("en-Us", {
		style: "currency",
		currency: "USD",
		minimumFractionDigits: 2,
	}).format;

	for (let perf of invoice.performances) {
		const play = plays[perf.playID];
		let thisAmount = 0;

		// switch 추출 (함수 추출하기)
		switch (play.type) {
			case "tregedy":
				thisAmount = 40000;
				if (perf.audience > 30) {
					thisAmount += 1000 * (perf.audience - 30);
				}
				break;
			case "comedy":
				thisAmount = 30000;
				if (perf.audience > 20) {
					thisAmount += 10000 + 500 * (perf.audience - 20);
				}
				thisAmount += 300 * perf.audience;
				break;

			default:
				throw new Error(`알 수 없는 장르: ${play.type}`);
		}

		volumeCredits += Math.max(perf.audience - 30, 0);

		if ("comedy" === play.type)
			volumeCredits += Math.floor(perf.audience / 5);

		// 청구 내역을 출력한다.
		result += ` ${play.name} : ${format(thisAmount / 100)} ${
			perf.audience
		} 석 \n`;
		totalAmount += thisAmount;
	}
	result += `총액 : ${format(totalAmount / 100)} \n`;
	result += `적립 포인트 : ${volumeCredits}점 \n`;
	return result;
}

const results = statement(invoices[0], plays);
console.log(results);
```

-   switch 문을 살펴보면 한 번의 공연에 대한 요금을 계산하고 있다.
-   이렇게 파악한 정보를 잊지 않으려면 재빨리 코드에 반영해야한다.
-   다시 분석하지 않아도 코드 스스로가 자신이 하는 일이 무엇인지 말해줘야 한다.
-   코드 조각을 별도 함수로 추출하는 방식으로 앞서 파악한 정보를 코드에 반영할 것이다.
-   추출한 함수에는 그 코드가 하는 일을 설명하는 이름을 지어준다.
-   코드 조각을 함수로 추출할 때 실수를 최소화해주는 절차 : `함수 추출하기`

#### 함수 추출하기

-   별도 함수로 빼냈을 때 유효 범위를 벗어나는 변수가 있는지 확인

```javascript
function amountFor(perf, play) {
	let thisAmount = 0;
	switch (play.type) {
		case "tregedy":
			thisAmount = 40000;
			if (perf.audience > 30) {
				thisAmount += 1000 * (perf.audience - 30);
			}
			break;
		case "comedy":
			thisAmount = 30000;
			if (perf.audience > 20) {
				thisAmount += 10000 + 500 * (perf.audience - 20);
			}
			thisAmount += 300 * perf.audience;
			break;

		default:
			throw new Error(`알 수 없는 장르: ${play.type}`);
	}
	return thisAmount;
}

~~~~생략;

for (let perf of invoice.performances) {
	const play = plays[perf.playID];
	let thisAmount = amountFor(perf, play); // 추출한 함수를 이용
	volumeCredits += Math.max(perf.audience - 30, 0);

	if ("comedy" === play.type) volumeCredits += Math.floor(perf.audience / 5);

	// 청구 내역을 출력한다.
	result += ` ${play.name} : ${format(thisAmount / 100)} ${
		perf.audience
	} 석 \n`;
	totalAmount += thisAmount;
}
```

-   아무리 간단한 수정이라도 리팩터링 후에는 항상 테스트하는 습관을 들이는 것이 바람직하다.
-   매번 테스트하는 것이 리팩터링 절차의 핵심이다.
-   조금씩 수정하여 피드백 주기를 짧게 가져가는 습관을 기르자.

-   리팩터링은 프로그램 수정을 작은 단계로 나눠 진행한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다.

-   amountFor() 를 statement() 의 중첩 함수로 만들 수 있었다. 이렇게 하면 바깥 함수에서 쓰던 변수를 새로 추출한 함수에 매개변수로 전달할 필요가 없어서 편하다.

-   변수 이름을 조금더 명확하게 바꿔보자
-   thisAmount -> result
-   perf -> aPerformance

```javascript
function amountFor(aPerformance, play) {
	let result = 0;
	switch (play.type) {
		case "tregedy":
			result = 40000;
			if (aPerformance.audience > 30) {
				result += 1000 * (aPerformance.audience - 30);
			}
			break;
		case "comedy":
			result = 30000;
			if (aPerformance.audience > 20) {
				result += 10000 + 500 * (aPerformance.audience - 20);
			}
			result += 300 * aPerformance.audience;
			break;

		default:
			throw new Error(`알 수 없는 장르: ${play.type}`);
	}
	return result;
}
```

-   자바ㅅ크립트와 같은 동적 타입 언어를 사용할 때는 타입이 드러나게 작성하면 도움된다.
-   매개변수 이름에 접두어로 타입이름을 적는다.
-   지금처럼 매개변수의 역할이 뚜렷하지 않을 때는 부정 관사 (a/an)을 붙인다.

**컴퓨터가 이해하는 코드는 바보도 작성할 수 있다. 사람이 이해하도록 작성하는 프로그래머가 진정한 실력자다**V

-   play 매개변수 제거하기

```javascript
function playFor(aPerformance) {
  return plays[aPerformance.playID];
}
~~~
let thisAmount = amountFor(perf, playFor(perf)); // 추출한 함수를 이용
```

```javascript
function usd(aNumber) {
	return new Intl.NumberFormat("en-Us", {
		style: "currency",
		currency: "USD",
		minimumFractionDigits: 2,
	}).format(aNumber / 100);
}

function volumeCreditsFor(aPerformance) {
	let result = 0;
	result += Math.max(aPerformance.audience - 30, 0);
	// 희극 관객 5명마다 추가 포인트 제공
	if ("comedy" === playFor(aPerformance).type)
		result += Math.floor(aPerformance.audience / 5);
	return result;
}

function playFor(aPerformance) {
	return plays[aPerformance.playID];
}

function amountFor(aPerformance) {
	// play 매개변수 삭제
	let thisAmount = 0;
	switch (
		playFor(aPerformance).type // play를 playFor() 호출로 변경
	) {
		case "tregedy":
			thisAmount = 40000;
			if (aPerformance.audience > 30) {
				thisAmount += 1000 * (aPerformance.audience - 30);
			}
			break;
		case "comedy":
			thisAmount = 30000;
			if (aPerformance.audience > 20) {
				thisAmount += 10000 + 500 * (aPerformance.audience - 20);
			}
			thisAmount += 300 * aPerformance.audience;
			break;

		default:
			throw new Error(`알 수 없는 장르: ${playFor(aPerformance).type}`);
	}
	return thisAmount;
}

function statement(invoice, plays) {
	// plays 매개변수 삭제
	let totalAmount = 0;
	let volumeCredits = 0;
	let result = `청구 내역 ( 고객명 : ${invoice.customer}\n`;

	for (let perf of invoice.performances) {
		volumeCredits += volumeCreditsFor(perf); // 추출한 함수를 이용해 값을 누적
		// 청구 내역을 출력한다.
		result += ` ${playFor(perf).name} : ${usd(amountFor(perf))} ${
			// thisAmount 변수를 인라인
			perf.audience
		} 석 \n`;
		totalAmount += amountFor(perf);
	}
	result += `총액 : ${usd(totalAmount)} \n`;
	result += `적립 포인트 : ${volumeCredits}점 \n`;
	return result;
}
```

-   함수 변수를 일반 함수로 변경하는 리팩터링 기법
-   format - usd 함수로 선언 변경
-   이름짓기는 중요하면서도 쉽지 않은 작업이다. 긴 함수를 작게 쪼개는 리팩터링은 이름을 잘 지어야만 효과가 있다.

##### volumeCredits 변수 제거하기

```javascript
let volumeCredits = 0; // 문장 스라이드하기를 적용해서 변수를 언언하는 문장을 반복문 앞으로 옮긴다.
for (let perf of invoice.performances) {
	// 값 누적 로직을 별도 for문으로 분리
	volumeCredits += volumeCreditsFor(perf);
}
```

-   값 누적이 여러 변수에서 일어나는 것은 리팩터링이 까다로움으로 반복문을 별도로 분리한다.
-   변수 선언을 반복문 앞으로 이동한다 (`문장 슬라이드하기`)

-   volumeCredits 값 갱신과 관련한 문장들을 한데 모아두면 `임시 변수를 질의 함수로 바꾸기`가 수월해짐

```javascript
function totalVolumeCredits(invoice) {
	let volumeCredits = 0;
	for (let perf of invoice.performances) {
		volumeCredits += volumeCreditsFor(perf);
	}
	return volumeCredits;
}

~~~state();

result += `적립 포인트 : ${totalVolumeCredits(invoice)}점 \n`; // 값 계산 로직을 함수로 추출하고 변수 인라인으로 정리
```

1. `반복문 쪼개기`로 변수 값을 누적시키는 부분을 분리한다.
2. `문장 슬라이드하기`로 변수 초기화 문장을 변수 값 누적 코드 바로 앞으로 옮긴다.
3. `함수 추출하기`로 적립 포인트 계산 부분을 별도 함수로 추출한다.
4. `변수 인라인하기` 로 volumeCredits 변수를 제거한다.

## 1.5 중간 점검 : 난무하는 중첩 함수

```javascript
function statement(invoice, plays) {
	let result = `청구 내역 ( 고객명 : ${invoice.customer}\n`;
	for (let perf of invoice.performances) {
		result += ` ${playFor(perf).name} : ${usd(amountFor(perf))} ${
			perf.audience
		} 석 \n`;
	}
	result += `총액 : ${usd(totalAmount())} \n`;
	result += `적립 포인트 : ${totalVolumeCredits()}점 \n`;
	return result;

	function totalAmount() {
		let result = 0;
		for (let perf of invoice.performances) {
			result += amountFor(perf);
		}
		return result;
	}

	function usd(aNumber) {
		return new Intl.NumberFormat("en-Us", {
			style: "currency",
			currency: "USD",
			minimumFractionDigits: 2,
		}).format(aNumber / 100);
	}

	function volumeCreditsFor(aPerformance) {
		let result = 0;
		result += Math.max(aPerformance.audience - 30, 0);
		// 희극 관객 5명마다 추가 포인트 제공
		if ("comedy" === playFor(aPerformance).type)
			result += Math.floor(aPerformance.audience / 5);
		return result;
	}
	function totalVolumeCredits() {
		let result = 0;
		for (let perf of invoice.performances) {
			result += volumeCreditsFor(perf);
		}
		return result;
	}

	function playFor(aPerformance) {
		return plays[aPerformance.playID];
	}

	function amountFor(aPerformance) {
		let thisAmount = 0;
		switch (playFor(aPerformance).type) {
			case "tregedy":
				thisAmount = 40000;
				if (aPerformance.audience > 30) {
					thisAmount += 1000 * (aPerformance.audience - 30);
				}
				break;
			case "comedy":
				thisAmount = 30000;
				if (aPerformance.audience > 20) {
					thisAmount += 10000 + 500 * (aPerformance.audience - 20);
				}
				thisAmount += 300 * aPerformance.audience;
				break;

			default:
				throw new Error(
					`알 수 없는 장르: ${playFor(aPerformance).type}`
				);
		}
		return thisAmount;
	} // amountFor() 끝
} // statement() 끝
```

-   최상위 statement() 함수는 이제 단 일곱 줄뿐이며, 출력할 문장을 생성하는 일만 한다.
-   계산 로직은 모두 여러 개의 보조 함수로 빼냈다.
-   결과적으로 계산 과정은 물론 전체 흐름을 이해하기가 훨씬 쉬워졌다.

## 1.6 계산 단계와 포맷팅 단계 분리하기

-   초반에는 코드의 구조를 보강하는 데 주안점을 두고 리팩터링을 한다.
-   복잡하게 얽힌 덩어리를 잘게 쪼개는 작업은 이름을 잘 짓는 일만큼 중요하다.

-   현재 모든 함수가 중첩으로 들어가 있으므로 `단계 쪼개기` 과정이 필요하다.
-   statement() 의 로직을 두 단계로 나누기
    1. 필요한 데이터 처리
    2. 앞서 처리한 결과를 텍스트나 HTML로 표현

`함수 추출하기`

```javascript
function statement(invoice, plays) {
	const statementData = {};
	return renderPlainText(statementData, invoice, plays);

	function renderPlainText(data, invoice, plays) {
		let result = `청구 내역 ( 고객명 : ${invoice.customer}\n`;
		for (let perf of invoice.performances) {
			result += ` ${playFor(perf).name} : ${usd(amountFor(perf))} ${
				perf.audience
			} 석 \n`;
		}
		result += `총액 : ${usd(totalAmount())} \n`;
		result += `적립 포인트 : ${totalVolumeCredits()}점 \n`;
		return result;
	}
```

-   이번에는 renderPlainText() 의 다른 두 인수 (invoice와 plays)를 살펴보자. 이 인수들을 통해 전달되는 데이터를 모두 방금 만든 중간 데이터 구조로 옮기면, 계산 관련 코드는 전부 statement()함수로 모으고 renderPlainText()는 data 매개변수로 전달된 데이터만 처리하게 만들 수 있다.

```javascript
	const statementData = {};
	statementData.customer = invoice.customer;
	return renderPlainText(statementData, invoice, plays);

	function renderPlainText(data, invoice, plays) {
		let result = `청구 내역 ( 고객명 : ${data.customer}\n`;
```

같은 방식으로 공연 정보까지 중간 데이터 구조로 옮기고 나면 renderPlainText()의 invoice 매개변수는 삭제해도 된다.

```javascript
statementData.customer = invoice.customer;
statementData.performances = invoice.performances.map(enrichPerformance);
return renderPlainText(statementData, plays);

function enrichPerformance(aPerformance) {
	const result = { ...aPerformance };
	return result;
}
```

-   얕은 복사 수행
-   여기서는 공연 객체를 복사하기만 했지만 잠시 후 이렇게 새로 만든 레코드에 데이터를 채울 것이다.
-   이때 복사를 한 이유는 함수로 건넨 데이터를 수정하기 싫어서다. 가변(mutable) 데이터는 금방 상하기 때문에
    나는 데이터를 최대한 불변(immutable) 처럼 취급한다.

## 함수 옮기기

-   playFor() 함수를 statement()로 옮겨보자
