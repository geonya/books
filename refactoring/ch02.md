# [Refactoring] Ch.02 리팩터링의 원칙

_220522_

## 2.1 리팩터링 정의

- 리팩터링 : [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구졸르 변경하는 기법
- 리팩터링(하다): [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성한다.

- 즉, 리팩터링은 동작을 보존하는 작은 단계뜰을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일
- 리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다. 프로그램 성능은 좋아질 수도 나빠질 수도 있다. (성능 최적화가 아님)

## 2.2 두 개의 작업 모드

- 소프트웨어를 개발할 때 목적은 `기능 추가` / `리팩터링` 으로 명확히 구분해서 작업해야 한다.
- `기능 추가 모드 : Add Mode` : 기존 코드는 절대 건드리지 않고 새 기능 추가에 집중
- `리팩터링 모드 : Refactoring Mode` : 새로운 기능 추가 없이 오로지 코드 재구성에만 전념
- 위 두 개의 모드를 번갈아 가며 작업하고 현재 어떤 모드에 있는지와 그에 따른 작업 방식의 차이를 분명하게 인식해야 한다.

## 2.3 리팩터링하는 이유

- **코드를 건강한 상태로 유지**

### 리팩터링하면 소프트웨어 설계가 좋아진다.

- 리팩터링하지 않으면 소프트웨어의 내부 설계 (아키텍처)가 썩기 쉽다.
- 아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다.
- 규칙적인 리팩터링은 코드의 구조를 지탱해준다.
- 중복 코드 제거는 설계 개선 작업의 중요한 한 축을 차지한다.
- 코드량이 줄어든다고 속도가 빨라지지 않지만 수정하는 데 드는 노력이 크게 줄어든다.
- **중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있으며 이는 바람직한 설계의 핵심이다.**

### 리팩터링하면 소프트웨어를 이해하기 쉬워진다.

- 컴퓨터에게 시키려는 일과 이를 표현한 코드의 차이를 최대한 줄여야 컴퓨터가 정확히 시킨 대로 반응한다.
- 코드가 잘 읽혀야 다른 프로그래머(나 자신도 포함)가 내 코드를 제대로 이해하고 쉽고 빠르게 작업을 진행할 수 있다.
- 리팩터링은 코드가 잘 읽히게 도와준다. 즉, 코드의 목적이 더 잘 드러나게, 내 의도를 더 명확하게 전달하도록 개선한다.

### 리팩터링하면 버그를 쉽게 찾을 수 있다.

- 리팩터링하면 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 된다.
- 프로그램의 구조를 명확하게 다듬으면 그냥 '이럴 것이다'라고 가정하던 점들이 분명히 드러나는데, 버그를 지나치려야 지나칠 수 없을 정도로 명확해진다.

> "난 뛰어난 프로그래머가 아니에요, 단지 뛰어난 습관을 지닌 괜찮은 프로그래머일 뿐이에요" - 켄트 벡 -

### 리팩터링하면 프로그래밍 속도를 높일 수 있다.

- 보통 새로운 기능을 추가할수록 기존 코드베이스에 잘 녹여낼 방법을 찾는데 시간이 오래 걸리고 버그가 발생하는 일이 잦다.
- 내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다.
- 모듈화가 잘 되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다.
- 코드가 명확하면 버그를 만들 가능성도 줄고, 버그를 만들더라도 디버깅하기가 훨신 쉽다.
- 내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대가 된다.
- `지구력 가설` : 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다.
- 리팩터링하면 기존 코드의 설계를 얼마든지 개선할 수 있으므로, 설령 프로그램 요구사항이 바뀌더라도 설계를 지속해서 개선할 수 있다.
  > 처음부터 좋은 설계를 마련하기란 매우 어렵다. 그래서 빠른 개발이라는 숭고한 목표를 달성하려면 리팩터링이 반드시 필요하다.

## 2.4 언제 리팩터링해야할까?

- 저자는 거의 한 시간 간격으로 리팩터링 한다.

### 3의 법칙

1. 처음에는 그냥 한다.
2. 비슷한 일을 두 번째로 하게 되면(중복을 체크), 일단 계속 진행
3. 비슷한 일을 세 번째 하게 되면 리팩터링 한다.

- 스트레아크 세 번이면 리팩터링하라(삼진 리팩터링)

### 준비를 위한 리팩터링 : 기능을 쉽게 추가하게 만들기

- 리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다.
- `함수 매개변수화하기`

  > 리팩터링 : "잠깐 지도를 보고 가장 빠른 경로를 찾아보자"

- 오류를 일으키는 코드가 세 곳에 복제되어 퍼져 있다면 우선 한 곳으로 합치는 편이 작업하기에 훨씬 편하다.
- 질의 코드에 섞여 있는 갱신 로직을 분리하면 두 작업이 꼬여서 갱기는 오류를 크게 줄일 수 있다.

### 이해를 위한 리팩터링 : 코드를 이해하기 쉽게 만들기

- 코드를 파악할 때마다 그 코드의 의도가 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다.
  - _조건부 로직의 구조가 이상하지 않은지_
  - _함수 이름을 잘못 정해서 실제로 하는 일을 파악하는 데 시간이 오래 걸리지는 않는지_
- 리팩터링하면 머리로 이해한 것을 코드에 옮겨 담을 수 있다. 그런 다음 수정한 코드를 테스트해보면 내 생각이 맞았는지 확인할 수 있다.
- 내가 이해한 것을 코드에 반영해두면 더 오래 보존할 수 있을 뿐만 아니라 동료들도 알 수 있다.

- 자잘한 세부 코드에 이해를 위한 리팩터링
  - _어떤 역할을 하는지 이해된 변수는 적절한 이름으로 변경_
  - _긴 함수를 잘게 나누기_

> 초기 단계의 리팩터링은 밖을 잘 내다보기 위한 창문 닦기이다. - 랄프 존슨 -

- **코드를 분석할 때 리팩터링을 해보면, 그렇지 않았더라면 도달하지 못했을 더 깊은 수준까지 이해하게 된다.**

### 쓰레기 줍기 리팩터링

- 코드를 파악하던 중에 비효율적으로 처리하는 모습을 발견하고 고치는 일
- 간단한 수정은 그때 그때, 좀 시간이 걸리는 수정은 메모를 남겨 나중에 수정
- 캠핑 규칙이 제안하듯, 항상 처음 봤을 대보다 깔끔하게 정리하고 떠나자.
- 리팩터링의 멋진 점은 각각의 작은 단계가 코드를 깨뜨리지 않는다는 사실이다. 그래서 작업을 잘게 나누면 몇 달에 걸쳐 진행하더라도 그 사이 한 순간도 코드가 깨지지 않기도 한다.

### 계획된 리팩터링과 수시로 하는 리팩터링

- 저자는 리팩터링 일정을 따로 잡아두지 않고, 기능을 추가하거나 버그를 잡는 동안 리팩터링도 함께 한다.

> 보기 싫은 코드를 발견하면 리팩터링하자, 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.
> <br />
> 무언가를 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고 그런 다음 쉽게 수정하자.

- 뛰어난 개발자는 새 기능을 추가하기 쉽도록 코드를 `수정` 하는 것이 그 기능을 가장 빠르게 추가하는 길일 수 있음을 안다.
- 소프트웨어 개발은 끝이 없는 작업이다. 새 기능이 필요할 때 새로 작성하는 코드의 양보다 기존 코드의 수정량이 더 많을 수도 있다.
- **계획된 리팩터링보다는 상시 리팩터링 모드를 유지하라.**

### 오래 걸리는 리팩터링

- 팀 전체가 리팩터링에 매달리기 보다는 주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적이다.

### 코드 리뷰에 리팩터링 활용하기

- 코드 리뷰는 개발팀 전체에 지식을 전파하는 데 좋고 다른 사람의 아이디어도 얻을 수 있다.
- 지금은 새로운 아이디어가 떠오르면 리팩터링하여 쉽게 구현해넣을 수 있는지부터 살펴본다.
- 이 과정을 반복하면 내가 떠올린 아이디어를 실제로 적용했을 때의 모습을 더 명확하게 볼 수 있다.

- 코드 리뷰의 개선안들을 제시하는 데서 그치지 않고, 그중 상당수를 즉시 구현할 수 있다.
- 가장 좋은 코드 리뷰 방법은 작성자와 나란히 앉아서 코드를 훑어가면서 리팩터링하는 것이다. : `짝 프로그래밍`

### 관리자에게는 뭐라고 말해야할까?

- 리팩터링한다고 굳이 말하지 말라.
- 프로 개발자에게 주어진 임무는 새로운 기능을 빠르게 구현하는 것이고, 가장 빠른 방법이 리팩터링인 것일 뿐이다.

### 리팩터링하지 말아야 할 때

- 외부 API 다루듯 호출해서 쓰는 코드 같이 굳이 수정할 필요가 없다면
- 처음부터 새로 작성하는 게 더 쉬울 때

## 2.5 리팩터링 시 고려할 문제

### 새 기능 개발 속도 저하

- 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

- 개발 속도 저하를 걱정하지 말고 리팩터링을 더 자주 하도록 노력하자.
- 리팩터링의 본질은 코드 베이스를 예쁘게 꾸미기 위해서가 아니라 오로지 경제적인 이유로 하는 것이다.
- 개발 시간 단축 :
  - 기능 추가 시간 줄이기
  - 버그 수정 시간 줄이기
  - 유지 보수 시간 줄이기

### 코드 소유권

#### 나에게 쓰기 권한이 없다면 ?

- `함수 이름 바꾸기` : 기존 함수를 그대로 유지하되 함수 본문에서 새 함수를 호출하도록 수정
- 코드 소유권을 팀에 두자. 팀원이라면 누구나 팀의 코드를 수정할 수 있도록

### 브랜치

- 독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기가 어려워진다.
- 머지와 통합을 명확히 구분한다.
  - 마스터를 브랜치로 `머지`하는 작업은 단방향이다.
  - `통합`은 마스터를 개인 브랜치로 가져와서 `pull` 작업한 결과를 다시 마스터에 올리는 `push` 양방향 처리를 뜻한다. (마스터와 브랜치 모두 변경됨)
- 기능별 브랜치의 통합 주기는 최대한 짧게 유지하자.
  - 지속적 통합 : Continuous Integration (CI) - 하루에 최소 한 번은 마스터와 통합
  - 트렁크 기반 개발 : Trunk-Based Development (TBD)

### 테스팅

- 리팩터링은 단계별 변경 폭이 작아서 도중에 발생한 오류의 원이 될만한 코드의 범위가 넓지 않다.
- 핵심은 오류를 재빨리 잡는 것이다.
- 이를 위해서는 코드의 다양한 측면을 검사하는 테스트 스위트 `test suite` 가 필요하다.
- 리팩터링하기 위해서는 자가 테스트 코드를 `self-testing code` 마련해야 한다.
- 자가 테스트 코드는 리팩터링을 할 수 있게 해줄 뿐만 아니라, 새 기능 추가도 훨씬 안전하게 진행할 수 있도록 도와준다.
- 자가 테스트 코드는 통합 과정에서 발생하는 의미 충돌을 잡는 메커니즘으로 활용할 수 있어서 자연스럽게 CI와도 밀접하게 연관된다.

### 레거시 코드

- Legacy Code 는 대체로 복잡하고 테스트도 제대로 갖춰지지 않은 것이 많다.
- 대규모 레거시 시스템을 테스트 코드 없이 명료하게 리팩터링하기는 어렵다.
- <레거디 코드 활용 전략>에 나온 지침을 따르자.
  > 프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다.
- 이 틈새를 만들 때 리펙터링이 활용됨
- 서로 관련된 부분끼리 나눠서 하나씩 공략하라. 조금이라도 개선하려고 노력하라. (캠핑 규칙)
- **코드를 훑게 되는 횟수가 많다는 말은 그 부분을 이해하기 쉽게 개선했을 때 얻는 효과도 그만큼 크다는 뜻이다**

### 데이터 베이스

- 데이터베이스 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리즈하는 것이 대체로 좋다는 점에서 다른 리팩터링과 다르다.

## 2.6 리팩터링, 아키텍처, 애그니(YAGNI)

- 리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드 베이스를 잘 설계해준다는 데 있다.
- (우리는 소프트웨어를 실제로 사용해보고 업무에 미치는 영향을 직접 확인하고 나서야 정말로 원하는 바를 알게 되는 경우가 허다하다)
- 리팩터링은 앞으로 어느 부분에 유연성이 필요하고 어떻게 해야 그 변화에 가장 잘 대응할 수 있을지 추축하지 않고, 그저 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축한다.
- 진행하면서 사용자의 여구사항을 더 잘 이해하게 되면 아키텍처도 그에 맞게 리팩터링해서 바꾼다.
- 그 과정에서 (작고 멋진 이름의 함수처럼) 소프트웨어의 복잡도에 지장을 주지 않는 메커니즘은 마음껏 추가하지만, 복잡도를 높일 수 있는 `유연성 메커니즘`은 반드시 검증을 거친 후에 추가한다.
- `유연성 메커니즘` : 예를 들어 함수를 정의하는 과정에서 다양한 예상 시나리오에 대응하기 위한 매개변수 등을 추가하는 등에 방법
- 만약 매개변수를 추가해야 할 시점이 오면 간단한 리팩터링 기법인 `함수 매개변수화하기` 로 해결한다.
- 이러한 설계 방식을 `간결한 설계 simple design`, `점진적 설계 incremental design`, `YAGNI 에그니 : You Aren't Going to Need It` 등으로 부른다.
- `진화형 아키텍처`는 아키텍처 관련 결정을 시간을 두고 반복해 내릴 수 있다는 장점을 활용하는 패턴과 실천법을 추구한다.

## 2.7 리팩터링과 소프트웨어 개발 프로세스

- **`XP Xtreme Programming` : 지속적 통합, 자가 테스트 코드, 리팩터링, 애자일**
  > 익스트림 프로그래밍(영어: eXtreme Programming, XP)는 켄트 백 등이 제안한 소프트웨어 개발 방법이다. 비즈니스 상의 요구가 시시각각 변동이 심한 경우에 적합한 개발 방법이다.
- **테스트 주도 개발 `TDD Test-Deriven Develpopment` : 자가 테스트 코드와 리팩터링을 묶음**
- `자가 테스트 코드` : 프로그래밍 도중 발생한 오류를 확실히 걸러래는 테스트를 자동으로 수행
- `지속적 통합`을 적용하면 팀원 각자가 수행한 리팩터링 결과를 빠르게 동료와 공유할 수 있다.
- 자가 테스트 코드 역시 지속적 통합의 핵심 요소다.
  - 조만간 삭제될 인터페이스를 이용하면 새로운 기능 추가 방지
  - 리팩터링한 결과가 다른 팀원의 작업에 문제를 일으키면 즉시 확인
- **자가 테스트코드, 지속적 통합, 리팩터링 세 기법을 잘 조화시키면 요구사항 변화에 재빠르게 대응하고 안정적인 선순한 구조를 코드베이스에 심을 수 있다.**
- `리팩터링`과 `YAGNI` 는 서로 긍정적인 영향을 준다.
- 추측에 근거한 수많은 유연성 메커니즘을 갖춘 시스템보다는 단순한 시스템이 변경하기가 훨씬 쉽게 때문이다.
- `지속적 배포`는 소프트웨어를 언제든 릴리즈할 수 있는 상태로 유지해준다.
- **이처럼 견고한 기술적 토대를 갖추면 좋은 아이디어를 프로덕션 코드로 반영하는 시간을 엄청나게 단출할 수 있어서 고객에게 더 좋은 서비스를 제공할 수 있다.**
- **더욱이 시간을 잡아먹는 버그의 수를 줄여줘서 소프트웨어의 신뢰성도 높일 수 있다.**

## 2.8 리팩터링과 성능

- 리팩터링하면 소프트웨어가 느려질 수 있는 것은 사실이지만 그와 동시에 성능을 튜닝하기는 더 쉬워진다.
- _먼저 튜닝하기 쉽게 만들고 나서 원하는 속도가 나게끔 튜닝하자_

- 빠른 소프트웨어를 작성하는 세 가지 방법
  1. 시간 예산 분배 방식 : (하드 리얼타임 시스템에 적합) 각 컴포넌트마다 자원(시간과 공간) 예산을 할당하여 절대로 초과할 수 없도록 관리
  2. 끊임없이 관심을 기울이기 :
  - 시스템에 대해 잘 알더라도 섣불리 추측하지 말고 성능을 측정하라
  - 대부분 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다. (코드 전체를 고르게 최적화하는 건 시간 낭비)
  3. **평소에 리팩터링을 잘해두기** :
  - 우선 코드를 다루기 쉽게 만드는데에 집중하고 이후 성능 개선하기
  - 프로파일러로 프로그램을 분석하여 시간과 공간을 많이 잡아먹는 지점을 알아냄
  - 사용자가 만족하는 성능에 도달할 대까지 최적화 대상을 찾아서 제거하는 일을 계속한다. (해당 부분 최적화는 리팩터링 원칙에 따라서)
- 잘 리팩터링 해두면 최적화의 두 가지 면에서 도움이 된다.

  - _성능 튜닝에 투입할 시간을 절약함_
  - _성능을 더 세밀하게 분석할 수 있음_

- **리팩터링은 성능 좋은 소프트웨어를 만드는 데 기여한다. 단기적으로 보면 리팩터링 단계에서 성능이 느려질 수도 있지만 최적화 단계에서 코드를 튜닝하기 훨씬 쉬워지기 때문에 결국 더 빠른 소프트웨어를 얻게 된다.**

## 2.10 리팩터링 자동화

- IDE가 제공하는 리팩터링 기능을 잘 활용하면 프로그래밍 효율이 높아진다.
- `언어 서버 Language Server` : 구문 트리를 구성해서 텍스트 에디터에 API 형태로 제공하는 소프트웨어
  - 다양한 텍스트 에디터를 지원할 수 있고, 정교한 코드 분석과 리팩터링 기능을 제공

## 2.11 더 알아보기

- <리팩터링 워크북> - 윌리엄 웨이크 -
- <패턴을 활용한 리팩터링> - 조슈아 케리에프스키 -
- <리팩토링 데이터베이스> - 스캇 엠블러, 프라모드 사달게 -
- <리팩토링 HTML> - 엘리엇 러스티 헤롤드 -
- <레거시 코드 활용 전략> - 마이클 페더스 -
- https://github.com/WegraLee/Refactoring
- https://refactoring.com

_220522_
