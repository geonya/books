# Ch.42 비동기 프로그래밍 asynchronous programming

## 동기 처리와 비동기 처리

- 함수가 실행되려면 함수 코드 평가 과정에서 생성된 함수 실행 컨텍스트가 실행 컨텍스트 스택에 푸시 되어야 한다.
- 함수 코드의 실행이 종료하면 함수 실행 컨텍스트는 실행 컨텍스트 스택에서 팝되어 제거된다.
- 함수가 호출된 순서대로 순차적으로 실행되는 이유는 함수가 호출된 순서대로 함수 실행 컨텍스트가 실행 컨텍스트 스택에 푸시되기 때문이다.
- 함수의 실행 순서는 실행 컨텍스트 스택으로 관리한다.
- 자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택을 갖는다.
- 이는 함수를 실행할 수 있는 창구가 단 하나이며, 동시에 2개 이상의 함수를 동시에 실행할 수 없다는 것을 의미
- 실행 컨텍스트 스택의 최상위 요소인 "실행 중인 실행 컨텍스트"를 제외한 모든 실행 컨텍스트는 모두 실행 대기 중인 태스크 Task 들이다.
- 대기 중인 태스크들은 현지 실행 중인 실행 컨텍스트가 팝되어 실행 컨텍스트 스택에서 제거되면, 다시 말해 현재 실행 중인 함수가 종료하면 비로소 실행되기 시작
- 싱글 스레드 방식은 한 번에 하나의 태스크만 실행할 수 있기 때문에 처리에 시간이 걸리는 태스크를 실행하는 경우 블로킹(작업중단)이 발생한다.
- 현재 실행 중인 태스크가 종료할 때까지 다음에 실행될 태스크가 대기하는 방식을 동기 synchronous 처리라고 한다.
- 현재 실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식을 비동기 asynchronous 처리라고 한다.

- 동기처리 방식은 태스크를 순서대로 하나씩 처리하므로 실행 순서가 보장되는 장점
- 태스크가 종료할 때까지 이후 태스크들이 블로킹되는 단점

- 비동기처리 방식은 현재 실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하므로 블로킹이 발생하지 않는 장점
- 태스크의 실행 순서가 보장되지 않는 단점

- setTimeout, setInterval, HTTP 요청, 이벤트 핸들러는 비동기 처리 방식으로 동작
- 비동기 처리는 이벤트 루프와 태스크 큐와 깊은 관계가 있다.

## 42.2 이벤트 루프와 태스크 큐

- 자바스크립트의 동시성을 지원하는 것이 바로 이벤트 루프다.

### 콜 스택 call stack

- 실행 컨텍스트가 추가되고 제거되는 스택 자료구조인 실행 컨텍스트 스택이 바로 콜스택이다.
- 자바스크립트 엔진은 단 하나의 콜 스택을 사용하기 때문에 최상위 실행 컨텍스트(실행 중인 실행 컨텍스트)가 종료되어 콜 스택에서 제거되기 전까지는 다른 어떤 태스크도 실행하지 않음

### 힙 heap

- 힙은 객체가 저장되는 메모리 공간
- 콜 스택의 요소인 실행 컨텍스트는 힙에 저장된 객체를 참조

- 콜 스택과 힙으로 구성되어 있는 자바스크립트 엔진은 단순히 태스크가 요청되면 콜 스택을 통해 요청된 작업을 순차적으로 실행할 뿐이다.
- **비동기 처리에서 소스코드의 평가와 실행을 제외한 모든 처리는 자바스크립트 엔진을 구동하는 환경인 브라우저 또는 Node.js가 담당한다**

### 태스크 큐

- setTimeout이나 setInterval 과 같은 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역
- 태스크큐와는 별도로 프로미스의 후속 처리 메서드의 콜백 함수가 일시적으로 보관되는 마이크로태스크 큐도 존재한다.

### 이벤트 루프

- 이벤트 루프는 콜 스택에 현재 실행 중인 실행 컨텍스트가 있는지, 그리고 태스크 큐에 대기 중인 함수(콜백 함수, 이벤트 핸들러 등)가 있는지 반복해서 확인한다.
- 만약 콜 스택이 비어 있고 태스크 큐에 대기 중인 함수가 있다면 이벤트 루프는 순차적으로 태스크 큐에 대기 중인 함수를 콜 스택으로 이동시킨다.
- 이때 콜 스택으로 이동한 함수는 실행된다. 즉, 태스크 큐에 임시 보관된 함수들은 비동기 처리 방식으로 동작한다.

- 브라우저 환경에서 작동 예제

```js
function foo() {
	console.log("foo");
}
function bar() {
	console.log("bar");
}

setTimeout(foo, 0); // 0초 (실제는 4ms) 후에 foo 함수가 호출된다.
bar();
```

1. 전역 코드가 평가되어 전역 실행 컨텍스트가 생성되고 콜 스택에 푸시됨
2. 전역 코드가 실행되기 시작하여 setTimeout 함수가 호출 -> 이때 setTimeout 함수의 함수 실행 컨텍스트가 생성되고 콜스택에 푸시 -> 현재 실행 중인 실행 컨텍스트가 됨. (브라우저의 Web API(호스트 객체)인 타이머 함수도 함수이므로 함수 실행 컨텍스트를 생성)
3. setTimeout 함수가 실행되면 콜백 함수를 호출 스케줄링하고 종료되어 콜 스택에서 팝된다.
   (이때 호출 스케줄링, 즉 타이머 설정과 타이머가 만료되면 콜백 함수를 태스크 큐에 푸시하는 것은 브라우저의 역할 )
4. 브라우저 수행하는 1.과 자바스크립트 엔진이 수행하는 2.는 병행 처리된다.
5. 브라우저는 타이머를 설정하고 만료를 기다린다. -> 타이머 만료 후 콜백 함수 foo 가 태스크 큐에 푸시 -> 4ms (4ms 이하로 지정할 경우 정해지는 최소 지연 시간) 후에 콜백 함수 foo가 태스크 큐에 푸시되어 대기 (브라우저가 수행)

   - setTimeout 함수로 호출 스케줄링한 콜백 함수는 정확히 지연 시간 후에 호출된다는 보장은 없음
   - 지연 시간 이후에 콜백 함수가 태스크 큐에 푸시되어 대기하게 되지만 콜 스택이 비어야 호출되므로 약간의 시간차가 발생할 수 있음

6. bar 함수가 호출되어 bar 함수의 함수 실행 컨텍스트가 생성 -> 콜스택에 푸시되어 현재 실행 중인 실행 컨텍스트가 됨 -> bar 함수가 종료되어 콜스택에서 팝

   - 이때 브라우저가 타이머를 설정한 후 4ms가 경과했다면 foo 함수는 아직 태스크 큐에서 대기 중일 것임

7. 전역 코드 실행이 종료되고 전역 실행 컨텍스트가 콜 스택에서 팝 -> 콜스택이 비게 됨
8. 이벤트 루프에 의해 콜 스택이 비어 있음을 감지 -> 태스크 큐에서 대기 중인 콜백 함수 foo가 이벤트 루프에 의해 콜 스택에 푸시 -> 콜백 함수 foo의 함수 실행 컨텍스트가 생성되고 콜 스택에 푸시 되어 현재 실행 중인 실행 컨텍스트가 됨 -> foo 함수가 종료되어 콜스택에서 팝

- 비동기 함수인 setTimeout 의 콜백함수는 태스크 큐에 푸시되어 대기하다가 콜 스택이 비게 되면 비로소 콜스택에 푸시되어 실행
- 싱글 스레드 방식으로 동작하는 것은 브라우저가 아니라 브라우저에 내장된 자바스크립트 엔진이라는 것
- 자바스크립트 엔진은 싱글 스레드로 동작하지만 브라우저는 멀티 스레드로 동작한다.
- 싱글 스레드 방식만으로는 비동기로 동작할 수 없다.
- 브라우저는 자바스크립트 엔진 외에도 렌더링 엔진과 Web API를 제공한다.
- Web API는 ECMAScript 사양에 정의된 함수가 아니라 브라우저에서 제공하는 API이며, DOM API와 타이머 함수, HTTP 요청(Ajax)과 같은 비동기 처리를 포함한다.

- 브라우저의 Web API인 setTimeout 함수가 호출되면 자바스크립트 엔진의 콜 스택에 푸시되어 실행
- 하지만 setTimeout 함수의 두 가지 기능인 타이머 설정과 타이머가 만료하면 콜백 함수를 태스크 큐에 등록하는 처리는 자바스크립트 엔진이 아니라 브라우저가 실행한다.
- 브라우저가 수행하는 4-1과 자바스크립트 엔진이 수행하는 4-2는 병행 처리된다.
- 이처럼 브라우저와 자바스크립트 엔진이 협력하여 비동기 함수인 setTimeout 함수를 실행하는 것이다!

- **자바스크립트 엔진은 싱글 스레드인데 어떻게 병렬처리 같은 비동기를 수행하나 했더니 브라우저가 멀티 스레드였던 것이다.**
